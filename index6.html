<!doctype html>
<html lang="zh-CN">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>恐龙大作战 - 环绕子弹 + 皮肤商店</title>
  <style>
    html, body { margin:0; padding:0; background:#0b1020; color:#e8ecff; font-family: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial; }
    .wrap { display:grid; place-items:center; min-height:100vh; }
    canvas { background: radial-gradient(1200px 800px at 60% 40%, #18234a 0%, #0b1020 55%, #070a14 100%);
      border: 1px solid rgba(255,255,255,.12); border-radius: 14px; box-shadow: 0 12px 40px rgba(0,0,0,.45); }
    .hud { position: fixed; top: 10px; left: 10px; right: 10px; display:flex; gap:10px; flex-wrap:wrap; pointer-events:none; }
    .pill { background: rgba(255,255,255,.08); border:1px solid rgba(255,255,255,.12); border-radius:999px; padding:8px 12px; font-size:14px; backdrop-filter: blur(6px); user-select:none;}
    .hint { position: fixed; bottom: 10px; left: 10px; right: 10px; opacity: .85; font-size: 13px; }
    .hint .pill { pointer-events:none; }

    .overlay { position: fixed; inset: 0; display: none; align-items: center; justify-content: center;
      background: rgba(0,0,0,.55); backdrop-filter: blur(6px); z-index: 50; }
    .panel { width: min(820px, calc(100vw - 28px)); background: rgba(12,16,36,.96);
      border: 1px solid rgba(255,255,255,.14); border-radius: 16px; box-shadow: 0 18px 60px rgba(0,0,0,.55); overflow: hidden; }
    .panel header { padding: 14px 16px; display:flex; align-items:center; justify-content:space-between; border-bottom: 1px solid rgba(255,255,255,.10); }
    .panel header h2 { margin:0; font-size:16px; }
    .panel header .sub { opacity:.8; font-size:13px; margin-top:2px; }
    .panel main { padding: 14px 16px; display:grid; gap:12px; }
    .grid { display:grid; grid-template-columns: 1fr 1fr; gap:10px; }
    @media (max-width: 760px) { .grid { grid-template-columns: 1fr; } }
    .card { border-radius:14px; border:1px solid rgba(255,255,255,.12); background: rgba(255,255,255,.06); padding:12px; display:grid; gap:10px; }
    .row { display:flex; align-items:center; justify-content:space-between; gap:10px; }
    .btn { pointer-events:auto; cursor:pointer; border-radius:12px; border:1px solid rgba(255,255,255,.18);
      background: rgba(255,255,255,.10); color:#e8ecff; padding:9px 11px; font-size:13px; user-select:none; }
    .btn:hover { background: rgba(255,255,255,.14); border-color: rgba(255,255,255,.26); }
    .btn.primary { background: rgba(99,143,255,.22); border-color: rgba(99,143,255,.40); }
    .btn.danger { background: rgba(255,99,132,.18); border-color: rgba(255,99,132,.35); }
    .tag { font-size:12px; padding:3px 8px; border-radius:999px; border:1px solid rgba(255,255,255,.18); background: rgba(255,255,255,.08); }
    .muted { opacity:.85; font-size:13px; }
    .k { opacity:.8; font-size:12px; }
    .skinPreview { display:flex; gap:10px; align-items:center; }
    .skinPreview img {
      width: 72px; height: 72px; object-fit: contain;
      background: rgba(0,0,0,.18);
      border: 1px solid rgba(255,255,255,.14);
      border-radius: 12px;
      padding: 6px;
    }
    .ok { color:#93ffb9; } .warn { color:#ffd28a; }
  </style>
</head>
<body>
  <div class="hud">
    <div class="pill" id="hudStage">Stage 1</div>
    <div class="pill" id="hudTime">Time: 60</div>
    <div class="pill" id="hudHP">HP: ❤❤❤</div>
    <div class="pill" id="hudGold">Gold: 0</div>
    <div class="pill" id="hudKills">Kills: 0</div>
    <div class="pill" id="hudScore">Score: 0</div>
    <div class="pill" id="hudOrbit">Orbit: bullets=1 size=x1</div>
  </div>

  <div class="wrap">
    <canvas id="c" width="960" height="540"></canvas>
  </div>

  <div class="hint">
    <div class="pill">WASD/方向键移动｜B 商店｜Esc 关闭商店｜R 重开｜子弹不追踪：绕着恐龙旋转，碰到怪物就打</div>
  </div>

  <!-- Shop overlay -->
  <div class="overlay" id="shopOverlay">
    <div class="panel">
      <header>
        <div>
          <h2>商店（B 打开 / Esc 关闭）</h2>
          <div class="sub">金币：击杀怪物 +1 ｜ 技能掉落：子弹变大 / 血量+1 / 子弹数量+1（永久）</div>
        </div>
        <button class="btn danger" id="btnCloseShop">关闭</button>
      </header>
      <main>
        <div class="row">
          <div class="tag">当前金币：<span id="shopGold">0</span></div>
          <div class="muted" id="shopStatus">—</div>
        </div>

        <div class="grid">
          <div class="card">
            <div class="row"><div><b>升级：环绕子弹数量 +1</b></div><span class="tag">250 金币</span></div>
            <div class="muted">让你同时有更多环绕子弹（永久）</div>
            <button class="btn primary" id="buyMoreBullets">购买</button>
            <div class="k" id="buyMoreBulletsState"></div>
          </div>

          <div class="card">
            <div class="row"><div><b>升级：子弹大小 +1级</b></div><span class="tag">250 金币</span></div>
            <div class="muted">环绕子弹更大，更容易碰到怪（永久）</div>
            <button class="btn primary" id="buyBigger">购买</button>
            <div class="k" id="buyBiggerState"></div>
          </div>
        </div>

        <div class="card">
          <div class="row"><div><b>皮肤商店</b></div><span class="tag">购买后可装备</span></div>
          <div class="grid" id="skinGrid"></div>
        </div>

        <div class="card">
          <div class="row"><div><b>已获得技能（掉落）</b></div><span class="tag">永久</span></div>
          <div class="muted" id="skillList">暂无</div>
        </div>
      </main>
    </div>
  </div>

  <script>
  (() => {
    const canvas = document.getElementById('c');
    const ctx = canvas.getContext('2d');
    const W = canvas.width, H = canvas.height;

    // HUD
    const hudStage = document.getElementById('hudStage');
    const hudTime  = document.getElementById('hudTime');
    const hudHP    = document.getElementById('hudHP');
    const hudGold  = document.getElementById('hudGold');
    const hudKills = document.getElementById('hudKills');
    const hudScore = document.getElementById('hudScore');
    const hudOrbit = document.getElementById('hudOrbit');

    // Shop UI
    const shopOverlay = document.getElementById('shopOverlay');
    const btnCloseShop = document.getElementById('btnCloseShop');
    const shopGold = document.getElementById('shopGold');
    const shopStatus = document.getElementById('shopStatus');
    const skillList = document.getElementById('skillList');

    const buyMoreBullets = document.getElementById('buyMoreBullets');
    const buyMoreBulletsState = document.getElementById('buyMoreBulletsState');
    const buyBigger = document.getElementById('buyBigger');
    const buyBiggerState = document.getElementById('buyBiggerState');
    const skinGrid = document.getElementById('skinGrid');

    // ======= 真实图片（你发的 6 张）======
    // 默认：拿炮小恐龙
    const IMG_DEFAULT = new Image();
    IMG_DEFAULT.src = "data:image/png;base64,{{DEFAULT_B64}}";

    // 五个皮肤（你刚发的）
    const SKINS = [
      { id:"beam_hat",  name:"激光帽",   price:600, src:"data:image/png;base64,{{S1_B64}}" },
      { id:"missile",   name:"火箭筒",   price:800, src:"data:image/png;base64,{{S2_B64}}" },
      { id:"king",      name:"国王披风", price:900, src:"data:image/png;base64,{{S3_B64}}" },
      { id:"beam_glow", name:"激光眼",   price:700, src:"data:image/png;base64,{{S4_B64}}" },
      { id:"fire",      name:"喷火龙",   price:650, src:"data:image/png;base64,{{S5_B64}}" },
    ];

    // ======= 简单音效 (WebAudio) =======
    const Audio = (() => {
      let ctxA = null;
      function ensure() {
        if (!ctxA) ctxA = new (window.AudioContext || window.webkitAudioContext)();
        return ctxA;
      }
      function beep(freq=440, dur=0.07, type='sine', vol=0.08) {
        const c = ensure();
        const o = c.createOscillator();
        const g = c.createGain();
        o.type = type; o.frequency.value = freq;
        g.gain.value = vol;
        o.connect(g); g.connect(c.destination);
        o.start();
        o.stop(c.currentTime + dur);
      }
      return {
        hit: () => beep(180, 0.06, 'square', 0.06),
        kill: () => beep(520, 0.07, 'triangle', 0.08),
        pickup: () => beep(740, 0.08, 'sine', 0.07),
        open: () => beep(320, 0.06, 'sine', 0.06),
      };
    })();

    // ======= 工具函数 =======
    const clamp = (v,a,b)=>Math.max(a,Math.min(b,v));
    const rand = (a,b)=>a+Math.random()*(b-a);
    const dist2 = (ax,ay,bx,by)=>{const dx=ax-bx,dy=ay-by; return dx*dx+dy*dy;};

    // ======= 输入 =======
    const keys = new Set();
    window.addEventListener('keydown', (e) => {
      const k = e.key.toLowerCase();
      if (['arrowup','arrowdown','arrowleft','arrowright',' '].includes(k)) e.preventDefault();
      keys.add(k);
      if (k === 'b' && !state.ended) toggleShop();
      if (k === 'escape' && state.shopOpen) closeShop();
      if (k === 'r') restart();
    }, { passive:false });
    window.addEventListener('keyup', (e) => keys.delete(e.key.toLowerCase()));

    // ======= 游戏状态 =======
    let state;
    function reset() {
      state = {
        player: {
          x: W/2, y: H/2, r: 18,
          speed: 260,
          hpMax: 3, hp: 3,
          sprite: IMG_DEFAULT,
          skinEquipped: "default",
        },
        gold: 0,
        kills: 0,
        score: 0,

        // orbit system
        orbitCount: 1,
        orbitSizeLv: 0,
        orbitBulletR: 8,
        orbitGap: 44,
        orbitSpeed: 2.05,
        orbitAngle: 0,

        // skill buffs (drops)
        buffs: { bigger: 0, hp: 0, more: 0 },

        // stage
        stage: 1,
        stageTime: 60,
        stageTimeLeft: 60,

        enemies: [],
        drops: [],

        shopOpen: false,
        ended: false,

        // skin ownership
        ownedSkins: { default: true },
      };

      // load owned skins
      try {
        const saved = JSON.parse(localStorage.getItem('dino_owned_skins_v1') || '{}');
        state.ownedSkins = { ...state.ownedSkins, ...saved };
      } catch {}

      buildSkinShop();
      updateShopUI();
      state.enemies = [];
      spawnWave();
      updateHUD();
    }

    // ======= 敌人/掉落 =======
    function enemyStats(stage) {
      const hp = 1 + Math.floor(stage / 4);
      const speed = 92 + stage * 8;
      const rangedChance = clamp((stage - 4) * 0.09, 0, 0.70);
      const bulletSpeed = 240 + stage * 12;
      const fireRate = clamp(1.10 - stage * 0.03, 0.40, 1.10);
      return { hp, speed, rangedChance, bulletSpeed, fireRate };
    }

    function spawnWave() {
      const base = 15;
      const extra = Math.floor(state.stage * 2.0);
      const n = base + extra;

      const s = enemyStats(state.stage);
      for (let i=0; i<n; i++) {
        const side = Math.floor(rand(0,4));
        let x,y;
        if (side===0) { x = rand(-160,-60); y = rand(-100, H+100); }
        if (side===1) { x = rand(W+60, W+160); y = rand(-100, H+100); }
        if (side===2) { x = rand(-100, W+100); y = rand(-160,-60); }
        if (side===3) { x = rand(-100, W+100); y = rand(H+60, H+160); }

        const ranged = Math.random() < s.rangedChance;
        state.enemies.push({
          x, y,
          r: ranged ? 14 : 12,
          hp: s.hp + (ranged ? 1 : 0),
          speed: s.speed * (ranged ? 0.96 : 1.06),
          ranged,
          fireCd: rand(0.2, 1.2),
          fireRate: s.fireRate,
          bulletSpeed: s.bulletSpeed,
          alive: true,
        });
      }
    }

    function maybeDrop(x,y) {
      if (Math.random() > 0.22) return;
      const pool = [
        { type: 'bigger', label: '技能：子弹变大' },
        { type: 'hp',     label: '技能：血量+1' },
        { type: 'more',   label: '技能：子弹数量+1' },
      ];
      const pick = pool[Math.floor(Math.random()*pool.length)];
      state.drops.push({ x, y, r: 10, type: pick.type, label: pick.label, t: 0, alive: true });
    }

    function applyDrop(type) {
      if (type === 'bigger') state.buffs.bigger += 1;
      if (type === 'hp') {
        state.buffs.hp += 1;
        state.player.hpMax += 1;
        state.player.hp = Math.min(state.player.hp + 1, state.player.hpMax);
      }
      if (type === 'more') state.buffs.more += 1;

      state.orbitCount = 1 + state.buffs.more;
      Audio.pickup();
      updateShopUI();
    }

    // ======= 环绕子弹位置 =======
    function orbitBullets() {
      const p = state.player;
      const count = state.orbitCount;
      const bullets = [];
      const gap = state.orbitGap + state.orbitSizeLv * 6;
      const angle0 = state.orbitAngle;

      const sizeMult = (1 + state.orbitSizeLv*0.25 + state.buffs.bigger*0.25);
      const br = state.orbitBulletR * sizeMult;

      for (let i=0; i<count; i++) {
        const a = angle0 + (Math.PI*2) * (i / count);
        const x = p.x + Math.cos(a) * gap;
        const y = p.y + Math.sin(a) * gap;
        bullets.push({ x, y, r: br });
      }
      return bullets;
    }

    // ======= 商店（升级 + 皮肤） =======
    btnCloseShop.onclick = () => closeShop();

    buyMoreBullets.onclick = () => {
      if (state.gold < 250) return setShopStatus("金币不够", true);
      state.gold -= 250;
      state.buffs.more += 1;
      state.orbitCount = 1 + state.buffs.more;
      Audio.open();
      setShopStatus("购买成功：子弹数量+1", false);
      updateShopUI();
    };

    buyBigger.onclick = () => {
      if (state.gold < 250) return setShopStatus("金币不够", true);
      state.gold -= 250;
      state.orbitSizeLv += 1;
      Audio.open();
      setShopStatus("购买成功：子弹更大", false);
      updateShopUI();
    };

    function setShopStatus(msg, warn=false) {
      shopStatus.textContent = msg;
      shopStatus.className = warn ? "muted warn" : "muted ok";
      setTimeout(()=>{ shopStatus.textContent = "—"; shopStatus.className="muted"; }, 1200);
    }

    function toggleShop() {
      if (state.shopOpen) closeShop();
      else openShop();
    }
    function openShop() {
      state.shopOpen = true;
      shopOverlay.style.display = 'flex';
      Audio.open();
      updateShopUI();
    }
    function closeShop() {
      state.shopOpen = false;
      shopOverlay.style.display = 'none';
    }

    function buildSkinShop() {
      skinGrid.innerHTML = '';

      const items = [
        { id: "default", name: "默认(炮)", price: 0, src: IMG_DEFAULT.src },
        ...SKINS.map(s => ({ id:s.id, name:s.name, price:s.price, src:s.src })),
      ];

      for (const it of items) {
        const owned = !!state.ownedSkins[it.id];
        const equipped = state.player.skinEquipped === it.id;

        const card = document.createElement('div');
        card.className = 'card';

        const img = document.createElement('img');
        img.src = it.src;

        const left = document.createElement('div');
        left.className = 'skinPreview';
        left.appendChild(img);

        const info = document.createElement('div');
        info.innerHTML = `<div><b>${it.name}</b></div><div class="muted">${it.price === 0 ? "免费" : (it.price + " 金币")}</div>`;
        left.appendChild(info);

        const row = document.createElement('div');
        row.className = 'row';
        row.appendChild(left);

        const btnWrap = document.createElement('div');
        btnWrap.style.display = 'flex';
        btnWrap.style.gap = '8px';

        const btnBuy = document.createElement('button');
        btnBuy.className = 'btn primary';
        btnBuy.textContent = owned ? '已拥有' : `购买`;
        btnBuy.disabled = owned || it.price === 0;

        const btnEquip = document.createElement('button');
        btnEquip.className = 'btn';
        btnEquip.textContent = equipped ? '已装备' : '装备';
        btnEquip.disabled = equipped;

        btnBuy.onclick = () => {
          if (owned) return;
          if (state.gold < it.price) return setShopStatus("金币不够", true);
          state.gold -= it.price;
          state.ownedSkins[it.id] = true;
          persistSkins();
          setShopStatus(`购买成功：${it.name}`, false);
          Audio.open();
          buildSkinShop();
          updateShopUI();
        };

        btnEquip.onclick = () => {
          if (!state.ownedSkins[it.id] && it.id !== "default") return setShopStatus("先购买再装备", true);
          equipSkin(it);
          buildSkinShop();
          updateShopUI();
        };

        btnWrap.appendChild(btnBuy);
        btnWrap.appendChild(btnEquip);
        row.appendChild(btnWrap);

        card.appendChild(row);

        const small = document.createElement('div');
        small.className = 'k';
        small.textContent = it.id === "default" ? "默认皮肤" : "只改变外观（不加属性）";
        card.appendChild(small);

        skinGrid.appendChild(card);
      }
    }

    function equipSkin(it) {
      state.player.skinEquipped = it.id;
      const img = new Image();
      img.src = it.src;
      state.player.sprite = img;
      setShopStatus(`已装备：${it.name}`, false);
      Audio.open();
    }

    function persistSkins() {
      try {
        localStorage.setItem('dino_owned_skins_v1', JSON.stringify(state.ownedSkins));
      } catch {}
    }

    function updateShopUI() {
      shopGold.textContent = state.gold.toString();
      buyMoreBulletsState.textContent = `当前：${state.orbitCount}（包含掉落技能加成）`;
      buyBiggerState.textContent = `当前：等级 ${state.orbitSizeLv}（掉落技能也会放大）`;

      const parts = [];
      if (state.buffs.bigger) parts.push(`子弹变大 +${state.buffs.bigger}`);
      if (state.buffs.hp) parts.push(`血量+${state.buffs.hp}`);
      if (state.buffs.more) parts.push(`子弹数量+${state.buffs.more}`);
      skillList.textContent = parts.length ? parts.join(" ｜ ") : "暂无";
    }

    // ======= 敌人子弹 =======
    const enemyBullets = [];
    function enemyShoot(e, p) {
      const dx = p.x - e.x, dy = p.y - e.y;
      const d = Math.hypot(dx,dy) || 1;
      const ux = dx/d, uy = dy/d;
      enemyBullets.push({ x: e.x, y: e.y, vx: ux*e.bulletSpeed, vy: uy*e.bulletSpeed, r: 6, alive:true });
    }

    // ======= HUD =======
    function updateHUD() {
      hudStage.textContent = `Stage ${state.stage}`;
      hudTime.textContent = `Time: ${Math.max(0, Math.ceil(state.stageTimeLeft))}`;
      hudHP.textContent = `HP: ${'❤'.repeat(state.player.hp)}${'·'.repeat(Math.max(0, state.player.hpMax - state.player.hp))}`;
      hudGold.textContent = `Gold: ${state.gold}`;
      hudKills.textContent = `Kills: ${state.kills}`;
      hudScore.textContent = `Score: ${state.score}`;

      const sizeMult = (1 + state.orbitSizeLv*0.25 + state.buffs.bigger*0.25);
      hudOrbit.textContent = `Orbit: bullets=${state.orbitCount} size=x${sizeMult.toFixed(2)}`;
    }

    // ======= 伤害 =======
    let invuln = 0;
    function damagePlayer() {
      if (invuln > 0) return;
      state.player.hp -= 1;
      invuln = 0.55;
      Audio.hit();
      if (state.player.hp <= 0) {
        state.ended = true;
      }
    }

    // ======= 更新逻辑 =======
    function step(dt) {
      if (state.ended) return;
      if (state.shopOpen) return;

      invuln = Math.max(0, invuln - dt);

      state.stageTimeLeft -= dt;
      if (state.stageTimeLeft <= 0) {
        state.stage += 1;
        state.stageTimeLeft = state.stageTime;
        spawnWave(); // 再刷一大波（堆叠更刺激）
      }

      // player move
      let mx=0,my=0;
      if (keys.has('w') || keys.has('arrowup')) my -= 1;
      if (keys.has('s') || keys.has('arrowdown')) my += 1;
      if (keys.has('a') || keys.has('arrowleft')) mx -= 1;
      if (keys.has('d') || keys.has('arrowright')) mx += 1;
      const len = Math.hypot(mx,my) || 1;
      mx/=len; my/=len;

      const p = state.player;
      p.x = clamp(p.x + mx*p.speed*dt, p.r, W-p.r);
      p.y = clamp(p.y + my*p.speed*dt, p.r, H-p.r);

      // orbit angle
      state.orbitAngle += state.orbitSpeed * dt;

      const orbs = orbitBullets();

      // enemies update
      for (const e of state.enemies) {
        if (!e.alive) continue;

        const dx = p.x - e.x, dy = p.y - e.y;
        const d = Math.hypot(dx,dy) || 1;
        const ux = dx/d, uy = dy/d;

        e.x += ux * e.speed * dt;
        e.y += uy * e.speed * dt;

        // touch player
        if (dist2(e.x,e.y,p.x,p.y) <= (e.r + p.r) ** 2) {
          // small knockback
          e.x -= ux * 10;
          e.y -= uy * 10;
          damagePlayer();
          if (state.ended) break;
        }

        // ranged shoot
        if (e.ranged) {
          e.fireCd -= dt;
          if (e.fireCd <= 0) {
            enemyShoot(e, p);
            e.fireCd = e.fireRate;
          }
        }

        // orbit bullet hits (no tracking)
        for (const b of orbs) {
          if (dist2(e.x,e.y,b.x,b.y) <= (e.r + b.r) ** 2) {
            e.hp -= 1;
            if (e.hp <= 0) {
              e.alive = false;
              state.kills += 1;
              state.gold += 1;
              state.score += 10 + Math.floor(state.stage * 2);
              Audio.kill();
              maybeDrop(e.x, e.y);
            }
            break;
          }
        }
      }

      // enemy bullets update
      for (const bl of enemyBullets) {
        if (!bl.alive) continue;
        bl.x += bl.vx * dt;
        bl.y += bl.vy * dt;
        if (bl.x < -80 || bl.x > W+80 || bl.y < -80 || bl.y > H+80) { bl.alive=false; continue; }
        if (dist2(bl.x,bl.y,p.x,p.y) <= (bl.r + p.r) ** 2) {
          bl.alive=false;
          damagePlayer();
          if (state.ended) break;
        }
      }

      // drops update
      for (const d of state.drops) {
        if (!d.alive) continue;
        d.t += dt;
        if (dist2(d.x,d.y,p.x,p.y) <= (d.r + p.r) ** 2) {
          d.alive = false;
          applyDrop(d.type);
        }
      }

      // cleanup
      state.enemies = state.enemies.filter(e => e.alive);
      state.drops = state.drops.filter(d => d.alive);
      for (let i=enemyBullets.length-1;i>=0;i--) if (!enemyBullets[i].alive) enemyBullets.splice(i,1);

      updateHUD();
    }

    // ======= 画面 =======
    function draw() {
      ctx.clearRect(0,0,W,H);

      // background dots
      ctx.save();
      ctx.globalAlpha = 0.08;
      ctx.fillStyle = '#ffffff';
      for (let y=18; y<H; y+=36) for (let x=18; x<W; x+=36) ctx.fillRect(x,y,1,1);
      ctx.restore();

      // drops
      for (const d of state.drops) {
        ctx.save();
        ctx.translate(d.x, d.y + Math.sin(d.t*6)*2);
        ctx.fillStyle = 'rgba(99,143,255,.95)';
        ctx.beginPath(); ctx.arc(0,0,d.r,0,Math.PI*2); ctx.fill();
        ctx.fillStyle = 'rgba(0,0,0,.45)';
        ctx.beginPath(); ctx.arc(0,0,d.r*0.55,0,Math.PI*2); ctx.fill();
        ctx.restore();
      }

      // enemy bullets
      for (const b of enemyBullets) {
        if (!b.alive) continue;
        ctx.save();
        ctx.fillStyle = 'rgba(140,208,255,.92)';
        ctx.beginPath(); ctx.arc(b.x,b.y,b.r,0,Math.PI*2); ctx.fill();
        ctx.restore();
      }

      // enemies
      for (const e of state.enemies) {
        ctx.save();
        ctx.fillStyle = e.ranged ? 'rgba(138,208,255,.92)' : 'rgba(255,122,168,.92)';
        ctx.beginPath();
        ctx.arc(e.x, e.y, e.r, 0, Math.PI*2);
        ctx.fill();

        // eyes
        ctx.fillStyle = 'rgba(0,0,0,.55)';
        ctx.beginPath();
        ctx.arc(e.x - e.r*0.25, e.y - e.r*0.18, Math.max(2, e.r*0.12), 0, Math.PI*2);
        ctx.arc(e.x + e.r*0.25, e.y - e.r*0.18, Math.max(2, e.r*0.12), 0, Math.PI*2);
        ctx.fill();

        // hp dots
        ctx.globalAlpha = 0.8;
        for (let i=0;i<Math.min(5,e.hp);i++){
          ctx.fillStyle = 'rgba(255,255,255,.35)';
          ctx.fillRect(e.x - 10 + i*5, e.y + e.r + 6, 3, 3);
        }
        ctx.restore();
      }

      // orbit bullets (draw above enemies for clarity)
      const orbs = orbitBullets();
      for (const b of orbs) {
        ctx.save();
        ctx.fillStyle = 'rgba(255,190,110,.95)';
        ctx.beginPath(); ctx.arc(b.x, b.y, b.r, 0, Math.PI*2); ctx.fill();
        ctx.globalAlpha = 0.35;
        ctx.strokeStyle = 'rgba(255,255,255,.75)';
        ctx.lineWidth = 2;
        ctx.beginPath(); ctx.arc(b.x, b.y, b.r, 0, Math.PI*2); ctx.stroke();
        ctx.restore();
      }

      // player sprite
      const p = state.player;
      const size = 86; // draw size
      ctx.save();
      if (invuln > 0) ctx.globalAlpha = 0.65;
      // sprite centered
      ctx.drawImage(p.sprite, p.x - size/2, p.y - size/2, size, size);
      ctx.restore();

      // game over text
      if (state.ended) {
        ctx.save();
        ctx.fillStyle = 'rgba(0,0,0,.55)';
        ctx.fillRect(0,0,W,H);
        ctx.fillStyle = 'rgba(255,255,255,.92)';
        ctx.font = 'bold 36px system-ui';
        ctx.fillText('游戏结束', W/2 - 72, H/2 - 16);
        ctx.font = '16px system-ui';
        ctx.fillText(`Kills: ${state.kills}   Score: ${state.score}   Stage: ${state.stage}`, W/2 - 170, H/2 + 18);
        ctx.fillText('按 R 重新开始', W/2 - 70, H/2 + 46);
        ctx.restore();
      }
    }

    // ======= 主循环 =======
    let last = performance.now();
    function loop(now) {
      const dt = Math.min(0.033, (now - last)/1000);
      last = now;
      step(dt);
      draw();
      requestAnimationFrame(loop);
    }

    function restart() {
      shopOverlay.style.display = 'none';
      reset();
    }

    // ======= 初始化 =======
    reset();
    requestAnimationFrame(loop);

  })();
  </script>

  <!-- 下面这些 {{...}} 会在复制前被替换成真正 base64 -->
</body>
</html>
