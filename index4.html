<!doctype html>
<html lang="zh-CN">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>恐龙大作战 (Dino Battle)</title>
  <style>
    html, body { margin: 0; padding: 0; background: #0b1020; color: #e8ecff; font-family: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial; }
    .wrap { display: grid; place-items: center; min-height: 100vh; }
    canvas { background: radial-gradient(1200px 800px at 60% 40%, #18234a 0%, #0b1020 55%, #070a14 100%); border: 1px solid rgba(255,255,255,.12); border-radius: 14px; box-shadow: 0 12px 40px rgba(0,0,0,.45); }
    .hud {
      position: fixed; top: 10px; left: 10px; right: 10px;
      display: flex; gap: 10px; align-items: center; flex-wrap: wrap;
      pointer-events: none;
    }
    .pill {
      background: rgba(255,255,255,.08);
      border: 1px solid rgba(255,255,255,.12);
      border-radius: 999px;
      padding: 8px 12px;
      font-size: 14px;
      backdrop-filter: blur(6px);
      pointer-events: none;
      user-select: none;
    }
    .hint { position: fixed; bottom: 10px; left: 10px; right: 10px; opacity: .85; font-size: 13px; }
    .hint .pill { pointer-events: none; }

    /* Overlay panels */
    .overlay {
      position: fixed; inset: 0; display: none; align-items: center; justify-content: center;
      background: rgba(0,0,0,.55);
      backdrop-filter: blur(6px);
      z-index: 50;
    }
    .panel {
      width: min(680px, calc(100vw - 28px));
      background: rgba(12,16,36,.96);
      border: 1px solid rgba(255,255,255,.14);
      border-radius: 16px;
      box-shadow: 0 18px 60px rgba(0,0,0,.55);
      overflow: hidden;
    }
    .panel header {
      padding: 14px 16px;
      display: flex; align-items: center; justify-content: space-between;
      border-bottom: 1px solid rgba(255,255,255,.10);
    }
    .panel header h2 { margin: 0; font-size: 16px; letter-spacing: .3px; }
    .panel header .sub { opacity: .75; font-size: 13px; }
    .panel main { padding: 14px 16px; display: grid; gap: 12px; }
    .grid { display: grid; grid-template-columns: 1fr 1fr; gap: 10px; }
    @media (max-width: 620px) { .grid { grid-template-columns: 1fr; } }

    .card {
      border-radius: 14px;
      border: 1px solid rgba(255,255,255,.12);
      background: rgba(255,255,255,.06);
      padding: 12px;
      display: grid;
      gap: 6px;
    }
    .row { display:flex; align-items:center; justify-content: space-between; gap: 10px; }
    .btn {
      pointer-events: auto;
      cursor: pointer;
      border-radius: 12px;
      border: 1px solid rgba(255,255,255,.18);
      background: rgba(255,255,255,.10);
      color: #e8ecff;
      padding: 9px 11px;
      font-size: 13px;
      transition: transform .06s ease, background .2s ease, border-color .2s ease;
      user-select: none;
    }
    .btn:hover { background: rgba(255,255,255,.14); border-color: rgba(255,255,255,.26); }
    .btn:active { transform: translateY(1px); }
    .btn.primary { background: rgba(99,143,255,.22); border-color: rgba(99,143,255,.40); }
    .btn.danger { background: rgba(255,99,132,.18); border-color: rgba(255,99,132,.35); }
    .muted { opacity: .8; font-size: 13px; }
    .k { opacity: .9; font-size: 12px; }
    .big { font-size: 18px; font-weight: 700; }
    input[type="text"]{
      width: 100%;
      box-sizing: border-box;
      border-radius: 12px;
      border: 1px solid rgba(255,255,255,.18);
      background: rgba(255,255,255,.06);
      color: #e8ecff;
      padding: 10px 12px;
      outline: none;
      font-size: 14px;
    }
    table { width: 100%; border-collapse: collapse; font-size: 13px; }
    th, td { padding: 8px 6px; border-bottom: 1px solid rgba(255,255,255,.10); text-align: left; }
    th { opacity: .85; font-weight: 600; }
    .tag { font-size: 12px; padding: 3px 8px; border-radius: 999px; border: 1px solid rgba(255,255,255,.18); background: rgba(255,255,255,.08); }
    .ok { color: #93ffb9; }
    .warn { color: #ffd28a; }
  </style>
</head>
<body>
  <div class="hud">
    <div class="pill" id="hudStage">World 1 / Stage 1</div>
    <div class="pill" id="hudTime">Time: 180</div>
    <div class="pill" id="hudHP">HP: ❤❤❤</div>
    <div class="pill" id="hudRevive">Revive: 1</div>
    <div class="pill" id="hudGold">Gold: 0</div>
    <div class="pill" id="hudScore">Score: 0</div>
    <div class="pill" id="hudUpg">DMG x1 | Size x1 | Radial: OFF</div>
  </div>

  <div class="wrap">
    <canvas id="c" width="960" height="540"></canvas>
  </div>

  <div class="hint">
    <div class="pill">操作：WASD/方向键移动｜B 商店｜Esc 关闭商店｜R 重开｜自动吐火球（瞄准最近敌人）</div>
  </div>

  <!-- Shop overlay -->
  <div class="overlay" id="shopOverlay">
    <div class="panel">
      <header>
        <div>
          <h2>商店（按 Esc 关闭）</h2>
          <div class="sub">金币来自击杀敌人（每个敌人 +1 金币）</div>
        </div>
        <button class="btn danger" id="btnCloseShop">关闭</button>
      </header>
      <main>
        <div class="row">
          <div class="big">当前金币：<span id="shopGold">0</span></div>
          <div class="muted">升级都是 <span class="tag">永久</span> 生效（直到本局结束）</div>
        </div>

        <div class="grid">
          <div class="card">
            <div class="row"><div class="big">100 金币</div><div class="tag">伤害翻倍</div></div>
            <div class="muted">DMG ×2（可叠加）</div>
            <button class="btn primary" id="buy100">购买</button>
            <div class="k" id="buy100State"></div>
          </div>

          <div class="card">
            <div class="row"><div class="big">200 金币</div><div class="tag">翻倍+变大</div></div>
            <div class="muted">DMG ×2（可叠加） + 火球大小 ×2</div>
            <button class="btn primary" id="buy200">购买</button>
            <div class="k" id="buy200State"></div>
          </div>

          <div class="card">
            <div class="row"><div class="big">300 金币</div><div class="tag">八向散射</div></div>
            <div class="muted">每次发射变成 8 方向发散火球</div>
            <button class="btn primary" id="buy300">购买</button>
            <div class="k" id="buy300State"></div>
          </div>

          <div class="card">
            <div class="row"><div class="big">600 金币</div><div class="tag">皮肤</div></div>
            <div class="muted">粉色小恐龙（外观）</div>
            <button class="btn primary" id="buy600">购买</button>
            <div class="k" id="buy600State"></div>
          </div>
        </div>

        <div class="card">
          <div class="row"><div class="big">已获得的随机技能（掉落）</div><div class="tag">永久加成</div></div>
          <div class="muted" id="skillList">暂无</div>
        </div>
      </main>
    </div>
  </div>

  <!-- Game over overlay -->
  <div class="overlay" id="endOverlay">
    <div class="panel">
      <header>
        <div>
          <h2 id="endTitle">游戏结束</h2>
          <div class="sub" id="endSub">保存到本地排行榜（只在你这台电脑/浏览器有效）</div>
        </div>
        <button class="btn" id="btnRestart">重新开始 (R)</button>
      </header>
      <main>
        <div class="card">
          <div class="row"><div class="big">本局结算</div><div class="tag" id="endTag">—</div></div>
          <div class="muted" id="endStats">—</div>
        </div>

        <div class="card">
          <div class="row"><div class="big">你的名字</div><span class="tag">用于排行榜</span></div>
          <input id="nameInput" type="text" maxlength="16" placeholder="输入名字（比如 Fang）" />
          <div class="row">
            <button class="btn primary" id="btnSave">保存成绩</button>
            <button class="btn" id="btnViewBoard">查看排行榜</button>
            <button class="btn danger" id="btnClearBoard">清空排行榜</button>
          </div>
          <div class="k" id="saveHint"></div>
        </div>

        <div class="card" id="boardCard" style="display:none;">
          <div class="row"><div class="big">排行榜 Top 10</div><span class="tag">localStorage</span></div>
          <div id="boardTable"></div>
        </div>
      </main>
    </div>
  </div>

<script>
(() => {
  // ===== Canvas =====
  const canvas = document.getElementById('c');
  const ctx = canvas.getContext('2d');

  // ===== HUD elements =====
  const hudStage = document.getElementById('hudStage');
  const hudTime  = document.getElementById('hudTime');
  const hudHP    = document.getElementById('hudHP');
  const hudRevive= document.getElementById('hudRevive');
  const hudGold  = document.getElementById('hudGold');
  const hudScore = document.getElementById('hudScore');
  const hudUpg   = document.getElementById('hudUpg');

  // ===== Overlays =====
  const shopOverlay = document.getElementById('shopOverlay');
  const endOverlay = document.getElementById('endOverlay');

  // Shop UI
  const shopGold = document.getElementById('shopGold');
  const skillList = document.getElementById('skillList');
  const buy100State = document.getElementById('buy100State');
  const buy200State = document.getElementById('buy200State');
  const buy300State = document.getElementById('buy300State');
  const buy600State = document.getElementById('buy600State');

  // End UI
  const endTitle = document.getElementById('endTitle');
  const endSub = document.getElementById('endSub');
  const endStats = document.getElementById('endStats');
  const endTag = document.getElementById('endTag');
  const nameInput = document.getElementById('nameInput');
  const saveHint = document.getElementById('saveHint');
  const boardCard = document.getElementById('boardCard');
  const boardTable = document.getElementById('boardTable');

  // Buttons
  document.getElementById('btnCloseShop').onclick = () => closeShop();
  document.getElementById('buy100').onclick = () => buyItem('buy100');
  document.getElementById('buy200').onclick = () => buyItem('buy200');
  document.getElementById('buy300').onclick = () => buyItem('buy300');
  document.getElementById('buy600').onclick = () => buyItem('buy600');

  document.getElementById('btnRestart').onclick = () => restart();
  document.getElementById('btnSave').onclick = () => saveScore();
  document.getElementById('btnViewBoard').onclick = () => { boardCard.style.display = ''; renderBoard(); };
  document.getElementById('btnClearBoard').onclick = () => clearBoard();

  // ===== Game constants =====
  const W = canvas.width, H = canvas.height;

  const clamp = (v, a, b) => Math.max(a, Math.min(b, v));
  const dist2 = (ax, ay, bx, by) => {
    const dx = ax - bx, dy = ay - by;
    return dx*dx + dy*dy;
  };
  const rand = (a, b) => a + Math.random() * (b - a);

  // ===== Input =====
  const keys = new Set();
  window.addEventListener('keydown', (e) => {
    if (['ArrowUp','ArrowDown','ArrowLeft','ArrowRight',' '].includes(e.key)) e.preventDefault();
    keys.add(e.key.toLowerCase());

    if (e.key.toLowerCase() === 'b') {
      if (!state.ended) toggleShop();
    }
    if (e.key === 'Escape') {
      if (state.shopOpen) closeShop();
    }
    if (e.key.toLowerCase() === 'r') {
      restart();
    }
  }, { passive: false });
  window.addEventListener('keyup', (e) => keys.delete(e.key.toLowerCase()));

  // ===== Entities =====
  function makePlayer() {
    return {
      x: W/2, y: H/2,
      r: 16,
      speed: 240, // px/sec
      hpMax: 3,
      hp: 3,
      reviveLeft: 1,
      color: '#8cffb1', // default green
      skinPink: false,
      invuln: 0, // seconds
    };
  }

  function makeEnemy(kind, x, y, cfg) {
    // kind: 'melee' or 'ranged' or 'boss'
    const base = {
      x, y,
      vx: 0, vy: 0,
      alive: true,
      hitFlash: 0,
      kind,
      fireCd: 0,
    };
    if (kind === 'boss') {
      return {
        ...base,
        r: cfg.bossRadius,
        hpMax: cfg.bossHP,
        hp: cfg.bossHP,
        speed: cfg.bossSpeed,
        dmgTouch: 1,
        color: '#ffcf6b',
        isBoss: true,
        ranged: cfg.bossRanged,
        fireRate: cfg.bossFireRate,
        bulletSpeed: cfg.bossBulletSpeed,
      };
    }
    const isRanged = (kind === 'ranged');
    return {
      ...base,
      r: isRanged ? 14 : 12,
      hpMax: isRanged ? 2 : 1,
      hp: isRanged ? 2 : 1,
      speed: cfg.enemySpeed * (isRanged ? 0.95 : 1.05),
      dmgTouch: 1,
      color: isRanged ? '#8ad0ff' : '#ff7aa8',
      ranged: isRanged,
      fireRate: isRanged ? cfg.rangedFireRate : 0,
      bulletSpeed: isRanged ? cfg.rangedBulletSpeed : 0,
    };
  }

  function makeBullet(x, y, vx, vy, r, dmg, from) {
    return { x, y, vx, vy, r, dmg, from, alive: true };
  }

  function makeDrop(x, y, type, label) {
    return { x, y, r: 10, type, label, alive: true, t: 0 };
  }

  // ===== Progression config =====
  // 3 worlds, each 5 stages, each stage 180 seconds
  function stageConfig(world, stage) {
    // world: 1..3, stage: 1..5
    const depth = (world - 1) * 5 + (stage - 1); // 0..14
    const spawnInterval = clamp(1.35 - depth * 0.06, 0.45, 1.35);
    const maxEnemies = clamp(6 + depth * 1.2, 6, 26);
    const enemySpeed = 105 + depth * 8;
    const rangedChance = clamp((depth - 5) * 0.06, 0, 0.55); // after ~world2
    const rangedFireRate = clamp(1.25 - depth * 0.03, 0.6, 1.25);
    const rangedBulletSpeed = 200 + depth * 10;

    // Boss settings
    const isBossStage = (stage === 5);
    const bossHP = isBossStage ? Math.round(60 + depth * 10) : 0;
    const bossSpeed = 95 + depth * 4;
    const bossRadius = 26 + world * 4;
    const bossRanged = (world >= 2); // later bosses can shoot
    const bossFireRate = clamp(0.95 - depth * 0.02, 0.45, 0.95);
    const bossBulletSpeed = 260 + depth * 12;

    return {
      spawnInterval,
      maxEnemies,
      enemySpeed,
      rangedChance,
      rangedFireRate,
      rangedBulletSpeed,
      isBossStage,
      bossHP,
      bossSpeed,
      bossRadius,
      bossRanged,
      bossFireRate,
      bossBulletSpeed,
    };
  }

  const FINAL_BOSS = {
    hp: 380,
    radius: 34,
    speed: 110,
    fireRate: 0.5,
    bulletSpeed: 360,
  };

  // ===== State =====
  let state;
  function resetState() {
    state = {
      player: makePlayer(),
      enemies: [],
      bullets: [],
      drops: [],
      gold: 0,
      kills: 0,
      score: 0,

      // upgrades
      dmgMult: 1,
      sizeMult: 1,
      radial: false,
      bought: { buy100: 0, buy200: 0, buy300: 0, buy600: 0 },

      // skill buffs (permanent this run)
      buffs: {
        speed: 0,     // percent
        dmg: 0,       // percent
        fireRate: 0,  // percent
        projSpeed: 0, // percent
        hpMax: 0,     // flat
      },

      // progression
      world: 1,
      stage: 1,
      stageTimeLeft: 180,
      stageElapsed: 0,
      spawnCd: 0,
      bossAlive: false,
      finalBoss: false,

      // shooting
      shootCd: 0,

      // UI
      shopOpen: false,
      ended: false,
      win: false,
      runTime: 0,
    };
  }
  resetState();

  // ===== Shop logic =====
  function toggleShop() {
    if (state.shopOpen) closeShop();
    else openShop();
  }
  function openShop() {
    state.shopOpen = true;
    shopOverlay.style.display = 'flex';
    updateShopUI();
  }
  function closeShop() {
    state.shopOpen = false;
    shopOverlay.style.display = 'none';
  }
  function buyItem(id) {
    const costs = { buy100: 100, buy200: 200, buy300: 300, buy600: 600 };
    const cost = costs[id];
    if (state.gold < cost) return;

    // One-time for 300 / 600, multi-buy for 100/200 allowed but limited to avoid crazy
    if ((id === 'buy300' || id === 'buy600') && state.bought[id] >= 1) return;
    if ((id === 'buy100' || id === 'buy200') && state.bought[id] >= 3) return; // cap stacking
    state.gold -= cost;
    state.bought[id]++;

    if (id === 'buy100') {
      state.dmgMult *= 2;
    } else if (id === 'buy200') {
      state.dmgMult *= 2;
      state.sizeMult *= 2;
    } else if (id === 'buy300') {
      state.radial = true;
    } else if (id === 'buy600') {
      state.player.skinPink = true;
      state.player.color = '#ff79d9';
    }
    updateShopUI();
  }

  function updateShopUI() {
    shopGold.textContent = state.gold.toString();
    buy100State.textContent = state.bought.buy100 ? `已购买 ${state.bought.buy100} 次（上限 3）` : '可购买（可叠加，上限 3）';
    buy200State.textContent = state.bought.buy200 ? `已购买 ${state.bought.buy200} 次（上限 3）` : '可购买（可叠加，上限 3）';
    buy300State.textContent = state.bought.buy300 ? '已购买 ✅' : '可购买（一次）';
    buy600State.textContent = state.bought.buy600 ? '已购买 ✅' : '可购买（一次）';

    const list = [];
    if (state.buffs.speed) list.push(`移速 +${state.buffs.speed}%`);
    if (state.buffs.dmg) list.push(`伤害 +${state.buffs.dmg}%`);
    if (state.buffs.fireRate) list.push(`射速 +${state.buffs.fireRate}%`);
    if (state.buffs.projSpeed) list.push(`火球速度 +${state.buffs.projSpeed}%`);
    if (state.buffs.hpMax) list.push(`最大血量 +${state.buffs.hpMax}`);
    skillList.textContent = list.length ? list.join(' ｜ ') : '暂无';
  }

  // ===== Leaderboard =====
  const LS_KEY = 'dino_battle_leaderboard_v1';
  function loadBoard() {
    try { return JSON.parse(localStorage.getItem(LS_KEY) || '[]'); }
    catch { return []; }
  }
  function saveBoard(entries) {
    localStorage.setItem(LS_KEY, JSON.stringify(entries));
  }
  function renderBoard() {
    const entries = loadBoard().slice(0, 10);
    if (!entries.length) {
      boardTable.innerHTML = `<div class="muted">暂无记录</div>`;
      return;
    }
    const rows = entries.map((e, i) => `
      <tr>
        <td>${i+1}</td>
        <td>${escapeHtml(e.name)}</td>
        <td>${e.score}</td>
        <td>${e.kills}</td>
        <td>${e.time}s</td>
        <td>${e.date}</td>
      </tr>
    `).join('');
    boardTable.innerHTML = `
      <table>
        <thead>
          <tr><th>#</th><th>名字</th><th>分数</th><th>击杀</th><th>用时</th><th>日期</th></tr>
        </thead>
        <tbody>${rows}</tbody>
      </table>
    `;
  }
  function clearBoard() {
    localStorage.removeItem(LS_KEY);
    renderBoard();
    saveHint.textContent = '排行榜已清空。';
  }
  function saveScore() {
    const name = (nameInput.value || '').trim() || 'Anonymous';
    const entries = loadBoard();
    const now = new Date();
    const date = `${now.getFullYear()}-${String(now.getMonth()+1).padStart(2,'0')}-${String(now.getDate()).padStart(2,'0')}`;
    const record = {
      name,
      score: state.score,
      kills: state.kills,
      time: Math.floor(state.runTime),
      date
    };
    entries.push(record);
    entries.sort((a,b) => b.score - a.score);
    saveBoard(entries.slice(0, 30));
    saveHint.innerHTML = `<span class="ok">已保存！</span> 现在可以点“查看排行榜”。`;
    renderBoard();
    boardCard.style.display = '';
  }

  function escapeHtml(s) {
    return s.replace(/[&<>"']/g, (c) => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'}[c]));
  }

  // ===== Combat & drops =====
  function currentFireInterval() {
    // base fire interval in seconds
    const base = 0.42; // feels good
    const fr = 1 + state.buffs.fireRate / 100;
    return base / fr;
  }
  function playerDamage() {
    const buff = 1 + state.buffs.dmg / 100;
    return 1 * state.dmgMult * buff;
  }
  function projectileSpeed() {
    const buff = 1 + state.buffs.projSpeed / 100;
    return 420 * buff;
  }

  function spawnEnemy() {
    const cfg = stageConfig(state.world, state.stage);
    if (state.enemies.length >= cfg.maxEnemies) return;

    // avoid spawning too close to player
    let x, y;
    const p = state.player;
    for (let i=0; i<20; i++) {
      x = rand(20, W-20);
      y = rand(20, H-20);
      if (dist2(x,y,p.x,p.y) > 160*160) break;
    }
    const kind = (Math.random() < cfg.rangedChance) ? 'ranged' : 'melee';
    state.enemies.push(makeEnemy(kind, x, y, cfg));
  }

  function spawnStageBoss() {
    const cfg = stageConfig(state.world, state.stage);
    if (!cfg.isBossStage) return;
    if (state.bossAlive) return;
    state.bossAlive = true;

    // spawn boss away from player
    const p = state.player;
    const corners = [
      {x: 80, y: 80},
      {x: W-80, y: 80},
      {x: 80, y: H-80},
      {x: W-80, y: H-80},
    ];
    corners.sort((a,b) => dist2(b.x,b.y,p.x,p.y) - dist2(a.x,a.y,p.x,p.y));
    const s = corners[0];
    const boss = makeEnemy('boss', s.x, s.y, cfg);
    boss.color = '#ffd66f';
    state.enemies.push(boss);
  }

  function spawnFinalBoss() {
    state.finalBoss = true;
    state.bossAlive = true;

    const p = state.player;
    const s = dist2(80,80,p.x,p.y) > dist2(W-80,H-80,p.x,p.y) ? {x:80,y:80} : {x:W-80,y:H-80};
    const boss = makeEnemy('boss', s.x, s.y, {
      bossRadius: FINAL_BOSS.radius,
      bossHP: FINAL_BOSS.hp,
      bossSpeed: FINAL_BOSS.speed,
      bossRanged: true,
      bossFireRate: FINAL_BOSS.fireRate,
      bossBulletSpeed: FINAL_BOSS.bulletSpeed,
    });
    boss.color = '#ff9b6b';
    boss.hpMax = FINAL_BOSS.hp;
    boss.hp = FINAL_BOSS.hp;
    boss.r = FINAL_BOSS.radius;
    boss.speed = FINAL_BOSS.speed;
    boss.ranged = true;
    boss.fireRate = FINAL_BOSS.fireRate;
    boss.bulletSpeed = FINAL_BOSS.bulletSpeed;
    state.enemies.push(boss);
  }

  function enemyDrop(x, y) {
    // drop chance
    const r = Math.random();
    if (r < 0.18) {
      // skill drop
      const pool = [
        { type: 'skill', label: '移速+10%', apply: () => { state.buffs.speed += 10; } },
        { type: 'skill', label: '伤害+20%', apply: () => { state.buffs.dmg += 20; } },
        { type: 'skill', label: '射速+15%', apply: () => { state.buffs.fireRate += 15; } },
        { type: 'skill', label: '火球速度+20%', apply: () => { state.buffs.projSpeed += 20; } },
        { type: 'skill', label: '最大血量+1', apply: () => {
          state.buffs.hpMax += 1;
          state.player.hpMax = 3 + state.buffs.hpMax;
          state.player.hp = Math.min(state.player.hp + 1, state.player.hpMax);
        }},
      ];
      const pick = pool[Math.floor(Math.random()*pool.length)];
      const d = makeDrop(x, y, 'skill', pick.label);
      d.apply = pick.apply;
      state.drops.push(d);
    } else if (r < 0.32) {
      // small heal orb (optional, but helpful)
      const d = makeDrop(x, y, 'heal', '回血+1');
      d.apply = () => {
        state.player.hp = Math.min(state.player.hp + 1, state.player.hpMax);
      };
      state.drops.push(d);
    }
  }

  // ===== Update & Draw =====
  function update(dt) {
    if (state.ended) return;
    if (state.shopOpen) return;

    state.runTime += dt;

    // stage timer
    state.stageTimeLeft -= dt;
    state.stageElapsed += dt;

    // movement
    const p = state.player;
    const speedBuff = 1 + state.buffs.speed / 100;
    let sp = p.speed * speedBuff;

    let mx = 0, my = 0;
    if (keys.has('w') || keys.has('arrowup')) my -= 1;
    if (keys.has('s') || keys.has('arrowdown')) my += 1;
    if (keys.has('a') || keys.has('arrowleft')) mx -= 1;
    if (keys.has('d') || keys.has('arrowright')) mx += 1;

    const len = Math.hypot(mx, my) || 1;
    mx /= len; my /= len;
    p.x = clamp(p.x + mx * sp * dt, p.r, W - p.r);
    p.y = clamp(p.y + my * sp * dt, p.r, H - p.r);

    // invuln timer
    p.invuln = Math.max(0, p.invuln - dt);

    // shooting (auto)
    state.shootCd -= dt;
    if (state.shootCd <= 0) {
      shootAtNearest();
      state.shootCd = currentFireInterval();
    }

    // spawns
    const cfg = stageConfig(state.world, state.stage);

    // normal enemies spawn until boss stage end
    state.spawnCd -= dt;
    if (state.spawnCd <= 0) {
      spawnEnemy();
      state.spawnCd = cfg.spawnInterval;
    }

    // boss spawn near end of stage 5 (last 25s) or when time runs out
    if (cfg.isBossStage) {
      if (!state.bossAlive && state.stageTimeLeft <= 25) spawnStageBoss();
    }

    // when stage timer ends -> next stage/world, BUT boss must be defeated in stage 5
    if (state.stageTimeLeft <= 0) {
      if (cfg.isBossStage && state.enemies.some(e => e.isBoss && e.alive)) {
        // force time to 0 but wait boss
        state.stageTimeLeft = 0;
      } else {
        advanceStage();
      }
    }

    // update enemies
    for (const e of state.enemies) {
      if (!e.alive) continue;

      // chase player
      const dx = p.x - e.x;
      const dy = p.y - e.y;
      const d = Math.hypot(dx, dy) || 1;
      const ux = dx / d, uy = dy / d;
      e.x = clamp(e.x + ux * e.speed * dt, e.r, W - e.r);
      e.y = clamp(e.y + uy * e.speed * dt, e.r, H - e.r);

      // ranged shoot
      if (e.ranged) {
        e.fireCd -= dt;
        if (e.fireCd <= 0) {
          fireEnemyBullet(e, p);
          e.fireCd = e.fireRate;
        }
      }

      // touch damage
      if (dist2(p.x,p.y,e.x,e.y) <= (p.r + e.r) ** 2) {
        if (p.invuln <= 0) {
          damagePlayer(1);
          p.invuln = 0.7; // invincibility
        }
      }

      e.hitFlash = Math.max(0, e.hitFlash - dt);
    }

    // bullets
    for (const b of state.bullets) {
      if (!b.alive) continue;
      b.x += b.vx * dt;
      b.y += b.vy * dt;

      // out of bounds
      if (b.x < -50 || b.x > W + 50 || b.y < -50 || b.y > H + 50) {
        b.alive = false;
        continue;
      }

      if (b.from === 'player') {
        // hit enemies
        for (const e of state.enemies) {
          if (!e.alive) continue;
          if (dist2(b.x,b.y,e.x,e.y) <= (b.r + e.r) ** 2) {
            e.hp -= b.dmg;
            e.hitFlash = 0.08;
            b.alive = false;
            if (e.hp <= 0) {
              killEnemy(e);
            }
            break;
          }
        }
      } else {
        // enemy bullet hit player
        if (dist2(b.x,b.y,p.x,p.y) <= (b.r + p.r) ** 2) {
          b.alive = false;
          if (p.invuln <= 0) {
            damagePlayer(1);
            p.invuln = 0.55;
          }
        }
      }
    }

    // drops
    for (const d of state.drops) {
      if (!d.alive) continue;
      d.t += dt;

      // pickup
      if (dist2(d.x,d.y,p.x,p.y) <= (d.r + p.r) ** 2) {
        d.alive = false;
        if (typeof d.apply === 'function') d.apply();
        if (state.shopOpen) updateShopUI();
      }
    }

    // cleanup
    state.enemies = state.enemies.filter(e => e.alive);
    state.bullets = state.bullets.filter(b => b.alive);
    state.drops = state.drops.filter(d => d.alive);

    // If finished world3 stage5 boss and no enemies -> spawn final boss once
    if (state.world === 3 && state.stage === 5) {
      const cfg2 = stageConfig(3,5);
      const bossStill = state.enemies.some(e => e.isBoss);
      if (!bossStill && !state.finalBoss && state.stageTimeLeft <= 0) {
        spawnFinalBoss();
      }
    }

    // if final boss defeated -> win
    if (state.finalBoss && !state.enemies.some(e => e.isBoss)) {
      endGame(true);
    }

    updateHUD();
  }

  function advanceStage() {
    // stage cleared
    state.score += 200;
    state.stageElapsed = 0;

    if (state.stage < 5) {
      state.stage++;
      state.stageTimeLeft = 180;
      state.spawnCd = 0.2;
      state.bossAlive = false;
    } else {
      // world end
      state.score += 500; // treat as boss/major progress bonus if boss already dead
      if (state.world < 3) {
        state.world++;
        state.stage = 1;
        state.stageTimeLeft = 180;
        state.spawnCd = 0.2;
        state.bossAlive = false;
      } else {
        // World 3 Stage 5 ended; if no final boss yet, keep timer 0 and wait/spawn final boss in update
        state.stageTimeLeft = 0;
      }
    }
  }

  function shootAtNearest() {
    const p = state.player;
    const target = nearestEnemy(p.x, p.y);
    if (!target) return;

    const dx = target.x - p.x;
    const dy = target.y - p.y;
    const d = Math.hypot(dx, dy) || 1;
    const ux = dx / d, uy = dy / d;

    const sp = projectileSpeed();
    const baseR = 6 * state.sizeMult;
    const dmg = playerDamage();
    if (!state.radial) {
      state.bullets.push(makeBullet(p.x + ux*(p.r+6), p.y + uy*(p.r+6), ux*sp, uy*sp, baseR, dmg, 'player'));
    } else {
      // 8-direction radial
      const dirs = [
        [1,0],[0.707,0.707],[0,1],[-0.707,0.707],[-1,0],[-0.707,-0.707],[0,-1],[0.707,-0.707]
      ];
      for (const [vx, vy] of dirs) {
        state.bullets.push(makeBullet(p.x, p.y, vx*sp, vy*sp, baseR*0.9, dmg*0.85, 'player'));
      }
    }
  }

  function fireEnemyBullet(e, p) {
    const dx = p.x - e.x;
    const dy = p.y - e.y;
    const d = Math.hypot(dx, dy) || 1;
    const ux = dx / d, uy = dy / d;
    const sp = e.bulletSpeed || 260;
    const r = e.isBoss ? 7 : 6;
    state.bullets.push(makeBullet(e.x + ux*(e.r+4), e.y + uy*(e.r+4), ux*sp, uy*sp, r, 1, 'enemy'));
  }

  function nearestEnemy(x, y) {
    let best = null;
    let bestD = Infinity;
    for (const e of state.enemies) {
      if (!e.alive) continue;
      const d = dist2(x, y, e.x, e.y);
      if (d < bestD) { bestD = d; best = e; }
    }
    return best;
  }

  function killEnemy(e) {
    e.alive = false;
    state.kills += 1;
    state.gold += 1;

    // score
    if (e.isBoss) {
      state.score += state.finalBoss ? 2000 : 500;
      // if boss cleared, allow stage to advance if timer already hit 0
      if (stageConfig(state.world, state.stage).isBossStage && !state.finalBoss) {
        // clear boss stage: if time <=0 then advance
        if (state.stageTimeLeft <= 0) advanceStage();
      }
    } else {
      state.score += 10;
    }

    enemyDrop(e.x, e.y);

    // update shop display if open
    if (state.shopOpen) updateShopUI();
  }

  function damagePlayer(amount) {
    const p = state.player;
    p.hp -= amount;
    if (p.hp <= 0) {
      if (p.reviveLeft > 0) {
        p.reviveLeft -= 1;
        p.hp = p.hpMax;
        p.invuln = 1.2;
      } else {
        endGame(false);
      }
    }
  }

  function endGame(win) {
    state.ended = true;
    state.win = win;
    closeShop();

    endOverlay.style.display = 'flex';
    endTitle.textContent = win ? '恭喜通关！' : '游戏结束';
    endTag.textContent = win ? 'WIN' : 'LOSE';
    endTag.className = 'tag ' + (win ? 'ok' : 'warn');

    const p = state.player;
    const w = `World ${state.world} / Stage ${state.stage}`;
    endStats.innerHTML =
      `进度：<b>${w}</b><br>` +
      `击杀：<b>${state.kills}</b> ｜ 金币：<b>${state.gold}</b><br>` +
      `分数：<b>${state.score}</b> ｜ 用时：<b>${Math.floor(state.runTime)}s</b><br>` +
      `升级：DMG x${state.dmgMult} ｜ Size x${state.sizeMult} ｜ Radial: ${state.radial ? 'ON' : 'OFF'}<br>` +
      `血量上限：<b>${p.hpMax}</b> ｜ 复活剩余：<b>${p.reviveLeft}</b>`;

    saveHint.textContent = '';
    boardCard.style.display = 'none';
    nameInput.value = nameInput.value || 'Fang';
  }

  function restart() {
    endOverlay.style.display = 'none';
    shopOverlay.style.display = 'none';
    resetState();
    updateHUD();
  }

  function updateHUD() {
    const p = state.player;
    hudStage.textContent = `World ${state.world} / Stage ${state.stage}${state.finalBoss ? ' (Final Boss)' : ''}`;
    hudTime.textContent = `Time: ${Math.max(0, Math.ceil(state.stageTimeLeft))}`;
    hudHP.textContent = `HP: ${'❤'.repeat(p.hp)}${'·'.repeat(Math.max(0, p.hpMax - p.hp))}`;
    hudRevive.textContent = `Revive: ${p.reviveLeft}`;
    hudGold.textContent = `Gold: ${state.gold}`;
    hudScore.textContent = `Score: ${state.score}`;
    hudUpg.textContent = `DMG x${state.dmgMult} | Size x${state.sizeMult} | Radial: ${state.radial ? 'ON' : 'OFF'}`;
  }

  function draw() {
    // clear
    ctx.clearRect(0, 0, W, H);

    // subtle grid dots
    ctx.save();
    ctx.globalAlpha = 0.08;
    ctx.fillStyle = '#ffffff';
    for (let y=18; y<H; y+=36) {
      for (let x=18; x<W; x+=36) {
        ctx.fillRect(x, y, 1, 1);
      }
    }
    ctx.restore();

    // drops
    for (const d of state.drops) {
      if (!d.alive) continue;
      ctx.save();
      ctx.translate(d.x, d.y);
      const bob = Math.sin(d.t * 6) * 2.2;
      ctx.translate(0, bob);

      if (d.type === 'skill') {
        ctx.fillStyle = 'rgba(99,143,255,.95)';
      } else {
        ctx.fillStyle = 'rgba(147,255,185,.95)';
      }
      ctx.beginPath();
      ctx.arc(0, 0, d.r, 0, Math.PI*2);
      ctx.fill();
      ctx.globalAlpha = 0.95;
      ctx.fillStyle = 'rgba(0,0,0,.55)';
      ctx.beginPath();
      ctx.arc(0, 0, d.r*0.58, 0, Math.PI*2);
      ctx.fill();
      ctx.restore();
    }

    // bullets
    for (const b of state.bullets) {
      if (!b.alive) continue;
      ctx.save();
      ctx.fillStyle = (b.from === 'player') ? 'rgba(255,190,110,.95)' : 'rgba(140,208,255,.95)';
      ctx.beginPath();
      ctx.arc(b.x, b.y, b.r, 0, Math.PI*2);
      ctx.fill();
      ctx.restore();
    }

    // enemies
    for (const e of state.enemies) {
      if (!e.alive) continue;
      ctx.save();
      ctx.fillStyle = e.hitFlash > 0 ? 'rgba(255,255,255,.95)' : e.color;
      ctx.beginPath();
      ctx.arc(e.x, e.y, e.r, 0, Math.PI*2);
      ctx.fill();

      // small eyes
      ctx.globalAlpha = 0.9;
      ctx.fillStyle = 'rgba(0,0,0,.55)';
      ctx.beginPath();
      ctx.arc(e.x - e.r*0.25, e.y - e.r*0.18, Math.max(2, e.r*0.12), 0, Math.PI*2);
      ctx.arc(e.x + e.r*0.25, e.y - e.r*0.18, Math.max(2, e.r*0.12), 0, Math.PI*2);
      ctx.fill();

      // hp bar for boss
      if (e.isBoss) {
        const barW = 160, barH = 10;
        const x = W/2 - barW/2;
        const y = 18 + 44;
        const t = clamp(e.hp / e.hpMax, 0, 1);

        ctx.globalAlpha = 1;
        ctx.fillStyle = 'rgba(0,0,0,.35)';
        roundRect(ctx, x, y, barW, barH, 8, true, false);
        ctx.fillStyle = 'rgba(255,255,255,.18)';
        roundRect(ctx, x, y, barW, barH, 8, false, true);

        ctx.fillStyle = 'rgba(255,135,110,.85)';
        roundRect(ctx, x, y, barW * t, barH, 8, true, false);

        ctx.fillStyle = 'rgba(255,255,255,.85)';
        ctx.font = '12px system-ui';
        ctx.fillText(state.finalBoss ? '大Boss' : '小Boss', x, y - 6);
      }

      ctx.restore();
    }

    // player
    const p = state.player;
    ctx.save();
    ctx.globalAlpha = (p.invuln > 0) ? 0.65 : 1;
    ctx.fillStyle = p.color;
    ctx.beginPath();
    ctx.arc(p.x, p.y, p.r, 0, Math.PI*2);
    ctx.fill();

    // little mouth flame hint
    ctx.globalAlpha = 0.9;
    ctx.fillStyle = 'rgba(255,190,110,.85)';
    ctx.beginPath();
    ctx.arc(p.x + p.r*0.6, p.y, 4, 0, Math.PI*2);
    ctx.fill();

    // outline
    ctx.globalAlpha = 0.35;
    ctx.strokeStyle = 'rgba(255,255,255,.55)';
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.arc(p.x, p.y, p.r, 0, Math.PI*2);
    ctx.stroke();

    ctx.restore();

    // stage text
    ctx.save();
    ctx.globalAlpha = 0.9;
    ctx.fillStyle = 'rgba(255,255,255,.88)';
    ctx.font = '14px system-ui';
    const cfg = stageConfig(state.world, state.stage);
    let tip = `敌人上限 ${Math.floor(cfg.maxEnemies)} | 刷怪间隔 ${cfg.spawnInterval.toFixed(2)}s`;
    if (cfg.rangedChance > 0) tip += ` | 远程怪概率 ${(cfg.rangedChance*100).toFixed(0)}%`;
    if (cfg.isBossStage) tip += ` | 小Boss：倒计时≤25秒出现`;
    if (state.finalBoss) tip = '最终战：大Boss！';
    ctx.fillText(tip, 16, H - 16);
    ctx.restore();
  }

  function roundRect(ctx, x, y, w, h, r, fill, stroke) {
    const rr = Math.min(r, w/2, h/2);
    ctx.beginPath();
    ctx.moveTo(x+rr, y);
    ctx.arcTo(x+w, y, x+w, y+h, rr);
    ctx.arcTo(x+w, y+h, x, y+h, rr);
    ctx.arcTo(x, y+h, x, y, rr);
    ctx.arcTo(x, y, x+w, y, rr);
    ctx.closePath();
    if (fill) ctx.fill();
    if (stroke) ctx.stroke();
  }

  // ===== Loop =====
  let last = performance.now();
  function frame(now) {
    const dt = Math.min(0.033, (now - last) / 1000);
    last = now;

    update(dt);
    draw();

    requestAnimationFrame(frame);
  }
  updateHUD();
  requestAnimationFrame(frame);

  // ===== Shop key states: show "can't buy" hints =====
  function canBuy(cost) { return state.gold >= cost; }

  // ===== end overlay hotkeys =====
  window.addEventListener('keydown', (e) => {
    if (!state.ended) return;
    if (e.key === 'Enter') saveScore();
  });

})();
</script>
</body>
</html>
